<?xml version="1.0" encoding="UTF-8"?>
<CATS version="1.8">
<Problem title="Вирт" lang="ru" tlimit="1" mlimit="256"
    inputFile="input.txt" outputFile="output.txt" author="А. Ким">

<Keyword code="o.linear"/>

<ProblemStatement>
<p>
Лексемы языка программирования <tt>Вирт</tt> задаются следующим набором регулярных выражений 
(для экранирования метасимволов использован символ '<tt>\</tt>', 
например регулярное выражение - '<tt>\*\)</tt>' задает последовательность символов '<tt>*)</tt>'):
<ul><tt>
	<li><i>цифра</i> ~--- [0-9]</li>
	<li><i>буква</i> ~--- [A-Za-z_]</li>
	<li><i>символ</i> ~--- [^'\n]|''</li> - символ из двух кавычек обозначает одну кавычку
	<li><i>многострочный_комментарий</i> ~--- {[^}]*}</li>
	<li><i>многострочный_комментарий</i> ~--- \(\*[^<tt>(\*\))</tt>]*\*\)</li>
	<li><i>строчный_комментарий</i> ~--- //[^EOF\n]*[EOF\n]</li>
	<li><i>пробельные символы</i> ~--- [ \t\n\r]+</li>
	<li><i>идентификатор</i> ~--- {<i>буква</i>}({<i>буква</i>}|{<i>цифра</i>})*</li>
	<li><i>число</i> ~--- {<i>цифра</i>}+</li>
	<li><i>шестнадцатеричное_число</i> ~--- $[0-9A-Fa-f]+</li>
	<li><i>экспонента</i> ~--- [Ee][+-]?{<i>число</i>}</li>
	<li><i>вещественное_число</i> ~--- {<i>число</i>}\.{<i>число</i>}</li>
	<li><i>вещественное_число</i> ~--- {<i>число</i>}(\.{<i>число</i>})?{<i>экспонента</i>}</li>
	<li><i>символьная_литера</i> ~--- '{<i>символ</i>}'</li>
	<li><i>символьная_литера</i> ~--- #[{<i>число</i>}{<i>шестнадцатеричное_число</i>}]</li>
	<li><i>строка</i> ~--- '{<i>символ</i>}*'</li> - строка может иметь длину 0, 2 или более символов.
</tt></ul>

<tt>Цифра, буква, символ и экспонента</tt> являются вспомогательными символами и не являются лексемами языка.
</p><p>

Помимо лексем выводимых из этих правил в лексику языка также входят ключевые слова, 
знаки операций и разделители, списки которых представлены ниже:
<ul>
	<li><tt> begin, forward, do, else, end, for, function, if, array, of, procedure, 
		program, record, then, to, type, var, while, break, continue, downto, exit, 
		repeat, until </tt></li>
	
	<li> <tt>and, div, mod, not, or, xor, +, -, *, /, ^, 
		+=, -=, *=, /=, &lt;, &gt;, &lt;=, &gt;=, =, &lt;&gt;, :=, @, .</tt></li>
	
	<li> <tt> (, ), [, ], ;, :, .., (символ запятая ',')</tt></li>
</ul>

Требуется написать программу, которая будет распознавать лексемы данного языка.
</p><p>
Программа должна пытаться составить текущую лексему из как можно большего числа символов,
например в строке '<tt>...</tt>.' следует сначала распознать '<tt>..</tt>', а затем '<tt>.</tt>'.
</p><p>
В процессе распознавания может встретиться одна из следующих ошибок.
</p><p>
Код ошибки ~--- описание ошибки:
<ul>
	<li>BadNL ~--- Символ '<tt>\n</tt>' (новая строка) посреди <tt>символьной литеры/строки</tt> (строковой константы)</li>
	<li>BadEOF ~--- Конец файла посреди <tt>строки/символьной литеры/многострочного комментария</tt></li>
	<li>BadChar ~--- Появление символа не являющегося продолжением текущей лексемы или началом новой</li>
	<li>NoExp ~--- Отсутствие <tt>числа</tt> в <tt>экспоненте вещественного числа</tt>
		(если за <tt>числом/вещественным числом</tt> встретился символ <tt>[Ee][+-]?</tt>, 
		то за ним должно следовать <tt>число</tt>)</li>

	<li>NoFract ~--- Отсутствие <tt>числа</tt> в дробной части <tt>вещественного числа</tt>
		(если за <tt>числом</tt> встретился символ точки '.', то за ним должно следовать <tt>число</tt>, 
		кроме того допустимым продолжением также является еще один символ точки '.', 
		в таком случае будут сформированы 2 лексемы <tt>число</tt> и разделитель '..', 
		любые другие продолжения должны вызвать ошибку <tt>NoFract</tt>)</li>

	<li>NoHex ~--- Отсутствие шестнадцатеричных цифр в записи <tt>шестнадцатеричного числа</tt></li>
	<li>NoCC ~--- Отсутствие кода символа после <tt>#</tt></li>
	<li>BadCC ~--- Код символа не попадает в промежуток [0, 127]</li>
</ul>
</p>
</ProblemStatement>

<InputFormat>
<p>
Входной файл содержит $N$ строк ASCII символов.
</p>
</InputFormat>

<OutputFormat>
<p>
Для каждой лексемы, за исключением пробельных символов и комментариев, 
в порядке их появления во входном файле, выведите сообщение в формате 
'<tt>Номер строки\tНомер столбца\tТип лексемы\tЛексема</tt>'
</p><p>

<tt>Номер строки/столбца</tt> - позиция первого символа лексемы во входном файле. 
Нумерация строк и столбцов начинается с 1. Символ табуляции переводит курсор в ближайшую следующую позицию с номером $P: P = 4n+1$
</p><p>

Для "значимых" типов лексем
выведите <tt>\tЗначение</tt> в формате, описанном ниже. 
</p><p>

Тип лексемы и формат вывода <tt>Значения</tt>:
<ul>
	<li>Строка (<tt>string</tt>) - значение строки (символы кавычек,
		обозначающие начало и конец строки, в значение строки не входят)</li>
	<li>Символьная литера (<tt>char</tt>) - значение символа, в виде соответствующего ASCII символа</li>
	<li>Число (<tt>integer</tt>) или шестнадцатеричное число (<tt>hex</tt>) - значение числа в десятичном представлении</li>
	<li>Вещественное число (<tt>real</tt>) - значение числа в формате '<tt>%.4E</tt>' (число представляется в виде 
		'<tt>$M$E[+-]$P$</tt>', где <tt>$M$</tt> ~--- мантиса (число в промежутке (1, 10), за исключением числа 0.0000) 
		с ровно 4 знаками после запятой, 
		<tt>$P$</tt> ~--- порядок (целое число с ровно 2 десятичными цифрами))</li>
	<li>Идентификатор (<tt>ident</tt>), знак операции (<tt>op</tt>), разделитель (<tt>sep</tt>) или 
		ключевое слово (<tt>keyword</tt>) - вывод значения не требуется</li>
</ul>

Сообщения для каждой лексемы выводить на новой строке.
</p><p>

В случае обнаружения ошибки выведите сообщение в формате 
'<tt>Номер строки\tНомер столбца\tКод ошибки</tt>' и завершите работу программы 
(выводить успешно распознанные лексемы до встречи ошибки <i>нужно</i>)
</p><p>

Для ошибок типа <tt>BadNL</tt>, <tt>Номер строки</tt> равен номеру строки, на которой началась строка.
</p><p>

Ошибка типа <tt>BadCC</tt>, должна возникнуть после считывания всего кода символа.
</p>
</OutputFormat>

<ProblemConstraints>
<p>$1 \le N \le 1000$</p>
</ProblemConstraints>

<Sample rank="1"><SampleIn src="67.in"/><SampleOut src="67.out"/></Sample>
<Sample rank="2"><SampleIn src="68.in"/><SampleOut src="68.out"/></Sample>

<Solution name="sol" src="sol.py" />
<Test rank="1-66,69-70"><Out use="sol"/></Test>
<Test rank="1-70"><In src="%0n.in"/></Test>
<Test rank="67-68"><Out src="%0n.out"/></Test>

<Testset tests="1-10" points="1" name="Basic"></Testset>
<Testset tests="11-19" points="1" name="IntAndHex"></Testset>
<Testset tests="20-31" points="1" name="Real"></Testset>
<Testset tests="32-38" points="1" name="String"></Testset>
<Testset tests="39-47" points="1" name="MultilineComment"></Testset>
<Testset tests="48-54" points="1" name="SinglelineComment"></Testset>
<Testset tests="55-62" points="1" name="Char"></Testset>
<Testset tests="63-68,69-70" points="1" name="Combi"></Testset>

<Import guid="std.strs" type="checker" />

</Problem>
</CATS>
